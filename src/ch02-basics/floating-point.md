# 浮動小数点演算と誤差

計算物理学では、連続的な物理量をコンピュータ上で離散的に扱います。その際、実数を表現するために浮動小数点数が用いられますが、この表現は有限のビット数で行われるため、本質的に近似であり、誤差の発生は避けられません。

本節では、この浮動小数点数に起因する誤差について解説し、それが数値計算の結果に与える影響と、その対策について学びます。誤差の存在を正しく理解し、適切に対処することは、信頼性の高いシミュレーションを行う上で極めて重要です。

## Rustにおける浮動小数点数

Rustの標準的な浮動小数点数型には、`f32`と`f64`の2種類があります。

- **`f32` (単精度浮動小数点数)**: 32ビットで数値を表現します。メモリ使用量が少なく高速ですが、表現できる範囲と精度には限りがあります。
- **`f64` (倍精度浮動小数点数)**: 64ビットで数値を表現します。`f32`よりも広い範囲と高い精度を持ち、科学技術計算における標準的な型として広く用いられます。

> [!IMPORTANT]
> **本書では`f64`を標準とします**
>
> 計算物理学の多くのシミュレーションでは、計算過程で発生する微小な誤差が積み重なり、最終的な結果に大きな影響を与えることがあります。そのため、本書では特に断りがない限り、より高い精度を持つ`f64`型を標準として使用します。

## 浮動小数点数に起因する誤差

浮動小数点数を用いる際に発生する代表的な誤差を3つ紹介します。

### 1. 丸め誤差 (Rounding Error)

コンピュータが2進法で数値を扱うことに起因する誤差です。10進法では有限桁で表現できる小数（例: `0.1`）が、2進法では無限小数となり、有限のビット数で正確に表現できない場合があります。その結果、最も近い表現可能な値に「丸め」られることで生じるのが丸め誤差です。

この影響を確認するために、簡単なコードを実行してみましょう。

```rust
fn main() {
    let a: f64 = 0.1;
    let b: f64 = 0.2;
    let sum = a + b;
    let expected: f64 = 0.3;

    println!("0.1 + 0.2 = {}", sum);
    println!("期待値     = {}", expected);
    println!("両者は等しいか？ => {}", sum == expected);

    // 内部的な表現を確認
    println!("実際の値 (内部表現): {:.20}", sum);
}
```

このコードを実行すると、以下のような結果が得られます。

```text
0.1 + 0.2 = 0.30000000000000004
期待値     = 0.3
両者は等しいか？ => false
実際の値 (内部表現): 0.30000000000000004441
```

`0.1 + 0.2` の計算結果が、期待する `0.3` とは微妙に異なる値になっていることがわかります。これは、`0.1` と `0.2` が2進数で正確に表現できず、それぞれが近似値として格納されているために発生します。

> [!WARNING]
> **浮動小数点数の直接比較は避ける**
>
> 丸め誤差のため、`==` 演算子による浮動小数点数の直接比較は予期せぬ結果を招く可能性があります。計算結果が特定の値と等しくなることを期待するようなロジックは避けるべきです。比較の方法については後述します。

### 2. 桁落ち (Cancellation Error)

桁落ちとは、値がほぼ等しい2つの数値の差を計算した際に、有効桁数が大幅に失われてしまう現象です。

例えば、二次方程式 $a x^2 + b x + c = 0$ の解の公式を考えます。

$$ x = (-b plus.minus sqrt(b^2 - 4a c))/(2a) $$

ここで、$b^2 gt.double abs(4a c)$ の場合、$sqrt(b^2 - 4a c) approx abs(b)$ となります。もし $b > 0$ であれば、一方の解 $x_1 = (-b + sqrt(b^2 - 4a c))/(2a)$ の分子において、$-b$ と $sqrt(b^2 - 4a c)$ がほぼ等しい値となり、桁落ちが発生します。

以下のコードは、$x^2 + 10^8 x + 1 = 0$ の解をナイーブな解の公式で計算する例です。

```rust
fn main() {
    let a: f64 = 1.0;
    let b: f64 = 1.0e8; // 1億 (大きな値にすることで桁落ちが顕著になる)
    let c: f64 = 1.0;

    let d = (b * b - 4.0 * a * c).sqrt();

    // -b と d は非常に近い値になる (絶対値が近い)
    println!("-b = {}", -b);
    println!(" d = {}", d);

    // 桁落ちが発生する計算
    let x1_naive = (-b + d) / (2.0 * a);

    // もう一方の解
    let x2 = (-b - d) / (2.0 * a);

    println!("\nナイーブな計算:");
    println!("x1 = {:.17}", x1_naive);
    println!("x2 = {:.17}", x2);

    // 桁落ちを回避する工夫
    // 解と係数の関係 x1 * x2 = c/a を利用する
    let x1_stable = c / (a * x2);

    println!("\n安定な計算:");
    println!("x1 = {:.17}", x1_stable);

    // 相対誤差を計算
    let relative_error = (x1_naive - x1_stable).abs() / x1_stable.abs();
    println!(
        "\n相対誤差: {:.2e} ({:.1}%)",
        relative_error,
        relative_error * 100.0
    );
}
```

実行結果：

```text
-b = -100000000
 d = 99999999.99999999

ナイーブな計算:
x1 = -0.00000000745058060
x2 = -100000000.00000000000000000

安定な計算:
x1 = -0.00000001000000000

相対誤差: 2.55e-1 (25.5%)
```

ナイーブな計算で得られた `x1` は、本来の値（約 $-1.0 times 10^(-8)$）と比較して精度が大幅に低下しています。一方、解と係数の関係 $x_1 x_2 = c/a$ を用いて $x_1 = c/(a x_2)$ と計算することで、桁落ちを回避し、より精度の高い解を得ることができました。

このように、計算順序やアルゴリズムを工夫することで、桁落ちを回避できる場合があります。

### 3. 情報落ち (Loss of Significance)

絶対値が非常に大きい数値と非常に小さい数値を足し算する際に、小さい数値が結果に反映されず、情報が失われてしまう現象を情報落ちと呼びます。

```rust
fn main() {
    let large_number: f64 = 1.0e16;
    let small_number: f64 = 1.0;

    let result = large_number + small_number - large_number;

    println!("(1.0e16 + 1.0) - 1.0e16 = {}", result);
    println!("期待値 = 1.0");
}
```

このプログラムの実行結果は `0.0` となります。`1.0e16 + 1.0` の計算において、`1.0` は `f64` が表現できる有効桁数の範囲外となり、無視されてしまったためです。

多数の数値の和を計算する場合、絶対値の小さいものから順に足し合わせることで、情報落ちの影響を軽減できることがあります。

## 誤差への対策

これらの誤差が避けられないものである以上、それらを念頭に置いたプログラミングが求められます。

### 浮動小数点数の比較

前述の通り、`==` を用いた直接比較は危険です。代わりに、2つの数値の差がごく小さい値（**許容誤差**、**イプシロン**とも呼ばれる）未満であるかどうかで判定するのが一般的です。

#### 絶対誤差による比較

最も単純な方法は、2つの数値の差の絶対値が許容誤差未満かを確認する方法です。

```rust
fn main() {
    let a: f64 = 0.1 + 0.2;
    let b: f64 = 0.3;

    let tolerance = 1e-10; // 許容誤差

    // 絶対誤差による比較
    if (a - b).abs() < tolerance {
        println!("絶対誤差の範囲で a と b は等しい");
    } else {
        println!("絶対誤差の範囲で a と b は等しくない");
    }
}
```

#### 相対誤差による比較

絶対誤差による比較は、比較する数値が非常に大きい場合や非常に小さい場合にうまく機能しないことがあります。例えば、`1.0e10` と `1.0e10 + 1.0` を比較する場合、その差 `1.0` は `1e-10` よりもはるかに大きいですが、値のスケールから考えれば両者は「ほぼ等しい」と見なしたいかもしれません。

このような場合には、相対誤差を用いるのが有効です。

```rust
fn relative_eq(a: f64, b: f64, tolerance: f64) -> bool {
    // ゼロ除算を避ける
    if a == 0.0 || b == 0.0 {
        return (a - b).abs() < tolerance;
    }
    (a - b).abs() / a.abs().max(b.abs()) < tolerance
}
```

この方法では、差を値の大きさで正規化するため、スケールに依存しない比較が可能になります。

> [!NOTE]
> **マシンイプシロン `f64::EPSILON`**
>
> Rustの標準ライブラリには、`f64::EPSILON` という定数が用意されています。これは「1.0と、1.0より大きい次の表現可能な`f64`の値との差」と定義されており、マシンイプシロンと呼ばれます。
> ただし、この値は非常に小さく（約 $2.22 times 10^(-16)$）、比較対象の数値のスケールによっては実用的でない場合があります。通常は、問題の性質に応じて適切な許容誤差 `tolerance` を独自に設定する必要があります。

#### 実践的な比較: `approx` クレート

多くの場合、上記のような比較関数を自前で実装するよりも、`approx` のような実績のあるクレートを利用するのが最善です。このクレートは、絶対誤差、相対誤差、およびULP（Unit in the Last Place）に基づいた、頑健で使いやすい比較関数を提供します。

`Cargo.toml` に以下を追加して `approx` を導入できます。

```toml
[dependencies]
approx = "0.5"
```

そして、`assert_relative_eq!` マクロなどを使ってテストを書くことができます。

```rust,noplayground
use approx::assert_relative_eq;

fn main() {
    let a: f64 = 0.1 + 0.2;
    let b: f64 = 0.3;

    // a と b が相対誤差の範囲で等しいことを表明する
    assert_relative_eq!(a, b, max_relative = 1e-10);

    println!("approxクレートを使って a と b がほぼ等しいことを確認しました。");
}
```

シミュレーションコード内の条件分岐などで比較を行いたい場合は、`relative_eq!`マクロや`abs_diff_eq!`マクロがブール値を返すため便利です。

本書では、テストコードなどで浮動小数点数の比較を行う際に `approx` クレートを積極的に利用します。

### 数値的に安定なアルゴリズムの選択

同じ問題を解くアルゴリズムでも、計算手順によって誤差の蓄積度合いが異なる場合があります。桁落ちの例で見たように、数式を適切に変形したり、より数値的に安定したアルゴリズムを選択したりすることが重要です。

### 高精度計算の利用

`f64` の精度でも不十分な場合は、より多くのビットを使って数値を表現する「多倍長浮動小数点数」ライブラリを利用するという選択肢もあります。

これについては、[次節「高精度計算」](./high-precision.md)で詳しく解説します。

## まとめ

本節では、計算物理学における基本でありながら、非常に重要な浮動小数点数の誤差について学びました。

- **丸め誤差・桁落ち・情報落ち**といった誤差は、浮動小数点数演算において本質的に避けられない。
- `==` による浮動小数点数の**直接比較は危険**であり、許容誤差を用いた比較が必要である。
- 計算順序の工夫や、**数値的に安定なアルゴリズム**の選択によって、誤差の影響を軽減できる。

シミュレーションを行う際は、常にこれらの誤差が結果に与える影響を意識することが、科学的に信頼できる結論を導くための第一歩となります。
