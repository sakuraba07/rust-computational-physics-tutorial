# なぜRustなのか

従来、計算物理学ではFortran、C/C++、Python、Julia、MATLABなどが広く使われてきました。これらの言語にはそれぞれ長所があり、特にPythonは科学計算のエコシステムが非常に充実しています。それでは、なぜ本書でRustを使うのでしょうか？

## Rustの主な利点

### 1. 安全性とパフォーマンスの両立

計算物理学では、大規模なシミュレーションや数値計算において実行速度が重要です。従来の主な選択肢には、次のようなトレードオフがありました。

- **C/C++**：高速ですが、メモリ管理のバグ（セグメンテーション違反、メモリリークなど）が起きやすいという課題があります。
- **Python**：書きやすい一方で、Python単体での実行速度は遅く、パフォーマンスが求められる部分はCやFortranで実装されたライブラリ（NumPyやSciPyなど）に依存しています。

これに対し、Rustは**所有権システム**という独自の仕組みにより、コンパイル時にメモリ安全性を保証しながら、C/C++に匹敵する実行速度を実現します。ガベージコレクタ（GC）によるオーバーヘッドもなく、予測可能なパフォーマンスが得られます。

### 2. データ競合のない並列処理

現代の計算物理学では、マルチコアCPUやGPUを活用した並列計算が不可欠です。しかし、並列プログラミングは難しく、特にデータ競合に起因するバグは発見と修正が非常に困難です。

Rustの所有権システムと型システムは、**コンパイル時にデータ競合を防ぐ**という、他の多くの言語にはない強力な特徴を持っています。

- **C/C++**：並列処理は可能ですが、データ競合の検出はプログラマの責任に委ねられます。
- **Python**：GIL（Global Interpreter Lock）の存在により、単一プロセス内での真の並列実行が制限されます（マルチプロセスによる並列化は可能です）。
- **Rust**：コンパイラがデータ競合を静的に検出し、安全な並列処理を保証します。

例えば、データ並列処理ライブラリの[Rayon](https://github.com/rayon-rs/rayon)を使えば、安全かつ高速な並列処理を簡潔に記述できます。

### 3. モダンな開発環境

Rustは、言語設計だけでなく開発ツールも現代的で、高い生産性を実現します。

- **Cargo**：依存関係の管理、ビルド、テスト、ドキュメント生成などを統合した公式ツール。
- **強力な型システム**：コンパイル時に多くのバグを検出できます。
- **優れたエラーメッセージ**：コンパイラが問題箇所と修正候補を丁寧に提示してくれます。
- **充実したドキュメント**：`cargo doc`コマンド一つで、依存クレートを含めたプロジェクト全体のドキュメントを生成・閲覧できます。

科学計算において、コードの再現性や長期的な保守性は極めて重要です。Rustの統一されたツールチェーンは、これらの維持を強力にサポートします。

#### 他言語との比較

計算物理学で広く使われてきた言語と比較すると、開発環境の違いは顕著です。

- **C/C++**：公式の統一パッケージマネージャが存在せず、ビルドシステム（Make, CMakeなど）や依存関係管理ツール（vcpkg, Conanなど）が乱立しています。このため、プロジェクトごとに異なるビルド手順を学ぶ必要があり、依存ライブラリを含めたビルドの再現性を確保するのが困難な場合があります。

- **Fortran**：長年、公式のパッケージマネージャが存在しませんでした。最近[fpm (Fortran Package Manager)](https://fpm.fortran-lang.org/)が登場しましたが、エコシステムはまだ発展途上です。多くのレガシーコードは、依然として手動でのビルド設定を必要とします。

- **Python**：pipやcondaといった成熟したパッケージマネージャが存在しますが、仮想環境の管理（venv, virtualenv, condaなど）を含め、ツールチェーンの選択肢が多くあります。ツールの組み合わせによっては、環境の互換性問題に直面することもあります。

Rustでは、`cargo new`でプロジェクトを作成し、`cargo add`で依存関係を追加、`cargo build`でビルド、`cargo test`でテストを実行するという一連の作業が、すべて`cargo`という統一されたツールで完結します。`Cargo.toml`ファイルで依存関係を管理するため、どの環境でも`cargo build`を実行するだけで同じビルドを再現できます。

なお、Juliaも同様にモダンな言語設計を持ち、Pkgという公式パッケージマネージャを備えています。Rustと同様、後発の言語であるため、開発環境の一貫性が高いという利点があります。

### 4. 成長する科学計算エコシステム

Rustの科学計算ライブラリは急速に発展しています。以下は、その代表的なクレートです。

- **ndarray**：N次元配列操作（NumPyのコア機能に相当）
- **nalgebra**：線形代数ライブラリ
- **plotters**：データ可視化・プロット
- **rayon**：データ並列処理
- **burn**：機械学習フレームワーク
- **polars**：高速なデータフレーム処理

まだPythonのSciPyやMATLABほど網羅的ではありませんが、既存のC/C++やFortranで実装されたライブラリ（GSL, LAPACK, BLASなど）を呼び出すためのバインディングも充実しています。

### 5. FFIによる他言語との連携

Rustは、他言語との相互運用性（FFI: Foreign Function Interface）に優れています。これにより、以下のようなハイブリッドなアプローチが可能です。

- PythonからRustの高速な関数を呼び出す（[PyO3](https://pyo3.rs/)や[maturin](https://www.maturin.rs/)を利用）
- RustからC、C++、Fortranなどの既存のライブラリを呼び出す
- アプリケーション全体はPythonで構築し、計算負荷の高い部分だけをRustで実装する

この特性を活かせば、既存のPythonスクリプトの性能ボトルネックとなっている箇所だけをRustで書き換える、といった段階的な導入も可能です。

#### FFIのオーバーヘッドについて

ただし、FFIの利用には以下のようなオーバーヘッドが伴います。

- **関数呼び出しのコスト**：言語の境界を越える際に追加のコストが発生します。
- **データ変換のコスト**：言語間で型やメモリレイアウトが異なる場合、その変換にコストがかかります。
- **メモリコピーの発生**：データの所有権や安全性を保証するために、言語間でデータを渡す際にメモリコピーが必要になる場合があります。

FFIを効果的に利用するには、以下の点に注意が必要です。

- **粒度を適切に保つ**：小さな関数を頻繁に呼び出すのではなく、ある程度まとまった計算を一度の呼び出しで処理する。
- **データの往復を最小化**：可能な限り、データを一度渡して計算を完了させ、結果だけを返すように設計する。
- **ゼロコピーを活用**：メモリレイアウトを共有できる場合は、NumPy配列と`ndarray`間のゼロコピー変換などを利用して、不要なコピーを避ける。

適切に設計すれば、FFIのオーバーヘッドは全体の計算時間に比べて無視できる程度になります。実際、NumPy自体もPythonとC/Fortranの間でFFIを利用しており、同様のトレードオフを考慮した上で高いパフォーマンスを実現しています。

## Rustの課題と現実的な考慮事項

ここまでRustのメリットを述べてきましたが、採用にあたっては以下の課題も考慮する必要があります。

### 1. 学習曲線

所有権システム、ライフタイム、トレイトといった、Rustには他の手続き型言語にはない独特の概念があり、他の言語と比較して学習コストが高いとされています。

### 2. 科学計算ライブラリの成熟度

Pythonの科学計算エコシステム（NumPy, SciPy, Matplotlib, pandasなど）は、長年の歴史を通じて非常に成熟しています。一方、Rustのエコシステムはまだ発展途上であり、ニッチな数値計算アルゴリズムや特定の物理分野に特化したライブラリが見つからない場合もあります。

ただし、基本的な線形代数、高速フーリエ変換（FFT）、常微分方程式ソルバーといった基本的なツールは既に利用可能です。また、前述の通り、必要に応じてC/Fortranなどで書かれた既存のライブラリをFFIで呼び出すことで、機能不足を補うこともできます。

### 3. コンパイル時間

Rustは、安全性とパフォーマンスを保証するために、コンパイル時に多くのチェックを行います。その結果、大規模なプロジェクトではコンパイル時間が長くなることがあります。インクリメンタルコンパイルやビルドキャッシュなどの機能によって改善は進んでいますが、Pythonのような対話的な開発スタイルに比べると、試行錯誤のサイクルは少し遅くなる場合があります。

### 4. プロトタイピングの速度

アイデアを素早く検証したい場合、PythonやJupyter Notebookの方が適していることもあります。Rustは型の明示やコンパイルが必須であるため、迅速なプロトタイピングには必ずしも向いていません。

## どんな時にRustを選ぶべきか

以上のメリットとデメリットを踏まえると、計算物理学においてRustは特に以下のような場合に有効です。

- 長時間実行される計算で、実行速度がボトルネックになっている場合
- マルチコアCPUの性能を最大限に引き出したい場合
- 大規模なデータを扱い、メモリ効率が厳しく求められる場合
- コードの安全性や保守性を高め、リファクタリングや機能追加を容易に行いたい場合
- 既存のPythonコードのパフォーマンスを改善したい場合

逆に、以下のような場合は、他の言語が適しているかもしれません。

- 迅速なデータ分析や、使い捨てのプロトタイピングが主目的の場合
- 既存のPythonライブラリに強く依存したエコシステムから離れられない場合
- チーム全体が他の言語に習熟しており、Rustの学習コストをかけるのが難しい場合

## まとめ

Rustは、**安全性、パフォーマンス、並列処理の容易さ**という点で、計算物理学において非常に魅力的な選択肢です。学習曲線やエコシステムの成熟度といった課題はありますが、それらを乗り越えることで得られる恩恵は大きく、特にパフォーマンスや信頼性が重視される研究・開発において強力なツールとなります。

本書では、Rustのこれらの強みを活かしながら、計算物理学の基本的な手法を実装し、その理解を深めていきます。
