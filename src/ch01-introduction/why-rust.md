# なぜRustを用いるのか

従来、計算物理学の分野では、Fortran、C/C++、Python、Julia、MATLABといったプログラミング言語が広く利用されてきました。これらの言語にはそれぞれ長所があり、特にPythonは科学技術計算におけるエコシステムが非常に充実しています。それでは、なぜ本書ではRustを採用するのでしょうか。

## Rustの主な利点

### 1. 安全性とパフォーマンスの両立

計算物理学における大規模なシミュレーションや数値計算では、実行速度が極めて重要です。この点において、従来の主要な言語には以下のようなトレードオフが存在しました。

- **C/C++**：高速な実行が可能ですが、メモリ管理に起因するバグ（セグメンテーション違反、メモリリークなど）が発生しやすいという課題があります。
- **Python**：記述が容易である一方、言語単体での実行速度は遅く、高いパフォーマンスが要求される計算処理は、CやFortranで実装された外部ライブラリ（NumPyやSciPyなど）に依存します。これは、新たな高速計算ライブラリを開発しようとする場合、Python単体では完結せず、CやFortranといった他の言語を併用する必要があることを意味します。
- **Julia**：高水準言語でありながら、JIT（Just-In-Time）コンパイラにより高いパフォーマンスを目指した言語です。しかし、ガベージコレクタ（GC）に依存するため、実行時のパフォーマンスに予測不可能な停止（pause）が発生する可能性があり、Rustのようなコンパイル時の厳密なメモリ安全性保証もありません。

これに対し、Rustは**所有権システム**という独自のメモリ管理機構により、コンパイル時にメモリ安全性を保証すると同時に、C/C++に匹敵する高い実行パフォーマンスを実現します。ガベージコレクタ（GC）に起因する実行時オーバーヘッドもなく、予測可能なパフォーマンスを得ることが可能です。

### 2. データ競合のない並列処理

現代の計算物理学において、マルチコアCPUやGPUといった並列計算資源の活用は不可欠です。しかし、並列プログラミングは本質的に複雑であり、特にデータ競合に起因するバグは、その発見と修正が非常に困難です。

Rustの所有権システムと型システムは、**コンパイル時にデータ競合を未然に防ぐ**という、他の多くの言語にはない強力な特性を備えています。

- **C/C++**：並列処理は可能ですが、データ競合の検出はプログラマの責任に委ねられます。
- **Python**：GIL（Global Interpreter Lock）の制約により、単一プロセス内での真の並列実行が制限されます（ただし、マルチプロセスによる並列化は可能です）。
- **Julia**：言語レベルで並列計算をサポートしていますが、データ競合の防止はプログラマの責任であり、Rustのようにコンパイラが安全性を保証するわけではありません。
- **Rust**：コンパイラがデータ競合を静的に検出し、安全な並列コードの記述を保証します。

例えば、データ並列ライブラリである[Rayon](https://github.com/rayon-rs/rayon)を利用することで、安全かつ高速な並列処理を簡潔に記述することが可能です。

<details>
<summary>GIL（Global Interpreter Lock）に関する補足</summary>

GIL（グローバルインタプリタロック）は、Pythonインタプリタに存在する排他ロックであり、単一のプロセス内において、一度に一つのスレッドだけがPythonのバイトコードを実行できるように制限する仕組みです。

**なぜGILが存在するのか**

Pythonのメモリ管理は、オブジェクトの参照カウントに基づいて行われます。GILは、この参照カウントをスレッドセーフに保つための単純かつ効果的な方法として導入されました。これにより、複数のスレッドが同時に同じメモリにアクセスして参照カウントを破壊する（そしてメモリリークやクラッシュを引き起こす）ことを防ぎます。また、C言語で書かれた多くの拡張ライブラリが、GILの存在を前提として、より容易に実装できるという利点もありました。

**パフォーマンスへの影響**

GILの存在により、Pythonでは単一プロセス内で複数のスレッドを作成しても、CPUコアが複数あっても、同時に計算処理を実行できるのは常に一つのスレッドだけです。そのため、計算負荷の高い（CPUバウンドな）タスクにおいては、マルチスレッドによる並列化を行ってもパフォーマンスが向上しません。

一方で、ファイルの読み書きやネットワーク通信のような、CPUが計算を行わずに待機している時間（I/O待ち）が多いタスク（I/Oバウンドなタスク）では、あるスレッドがI/O待ちでブロックされている間に、別のスレッドが実行されるため、マルチスレッドは有効に機能します。

**回避策**

CPUバウンドなタスクでマルチコアの恩恵を受けるためには、スレッドではなく複数のプロセスを使用する**マルチプロセス**が一般的な解決策となります。各プロセスは独自のインタプリタとメモリ空間を持つため、それぞれが独立したGILを持ち、複数のCPUコア上で同時に実行することが可能です。

**近年の動向**

なお、近年ではGILを完全に取り除く（GILフリー）バージョンのPythonを導入する提案（PEP 703）が採択され、将来のPythonバージョンでオプショナルなビルドモードとして利用可能になることが計画されています。これが実現すれば、PythonのマルチスレッドにおけるCPUバウンドなタスクの並列実行に関する制約は、大きく変わる可能性があります。

</details>

### 3. モダンな開発環境

Rustは、言語設計のみならず、現代的で生産性の高い開発ツール群を提供します。

- **Cargo**：依存関係の管理、ビルド、テスト、ドキュメント生成などを統合した公式ツール。
- **強力な型システム**：コンパイル時の静的解析により、多くのバグを未然に検出することが可能です。
- **優れたエラーメッセージ**：コンパイラが問題箇所と修正候補を丁寧に提示します。
- **充実したドキュメント**：`cargo doc`コマンド一つで、依存クレートを含めたプロジェクト全体のドキュメントを生成・閲覧することが可能です。

科学技術計算において、コードの再現性や長期的な保守性は極めて重要です。Rustの統一されたツールチェーンは、これらの維持を強力に支援します。

#### 他言語との比較

計算物理学で広く使われてきた言語と比較すると、開発環境の違いは顕著です。

- **C/C++**：公式の統一パッケージマネージャが存在せず、ビルドシステム（Make, CMakeなど）や依存関係管理ツール（vcpkg, Conanなど）が多岐にわたります。このため、プロジェクトごとに異なるビルド手順を習得する必要があり、依存ライブラリを含めたビルドの再現性確保が困難な場合があります。

- **Fortran**：公式のパッケージマネージャが存在しません。近年コミュニティ主導で[fpm (Fortran Package Manager)](https://fpm.fortran-lang.org/)が登場しましたが、そのエコシステムは依然として発展途上です。多くの既存コードは、手動でのビルド設定を必要とします。

- **Python**：pipやcondaといった成熟したパッケージマネージャが存在しますが、仮想環境の管理（venv, virtualenv, condaなど）を含め、ツールチェーンの選択肢が多様です。このため、ツールの組み合わせによっては環境の互換性問題に直面することもあります。

これに対し、Rustでは`cargo new`によるプロジェクト作成、`cargo add`による依存関係の追加、`cargo build`によるビルド、`cargo test`によるテスト実行といった一連の作業が、すべて`cargo`という単一のツールで完結します。`Cargo.toml`ファイルによって依存関係が宣言的に管理されるため、どの環境でも`cargo build`を実行するだけで同一のビルドを再現できます。

なお、Juliaも同様に現代的な言語設計思想を持ち、公式パッケージマネージャであるPkgを備えています。Rustと同様、後発の言語であるため、開発環境の一貫性が高いという利点を共有しています。

### 4. 成長を続ける科学計算エコシステム

Rustの科学技術計算エコシステムは急速に発展しています。以下に、その代表的なクレート（ライブラリ）を挙げます。

- **ndarray**：N次元配列操作（NumPyのコア機能に相当）
- **nalgebra**：線形代数計算
- **plotters**：データ可視化・プロット
- **rayon**：データ並列処理
- **burn**：機械学習フレームワーク
- **polars**：高速なデータフレーム処理

現時点では、PythonのSciPyやMATLABほど網羅的ではありませんが、既存のC/C++やFortranで実装された著名なライブラリ（GSL, LAPACK, BLASなど）を呼び出すためのバインディングも充実しています。

### 5. FFIによる他言語との連携

Rustは、他言語との相互運用性（FFI: Foreign Function Interface）に優れています。これにより、以下のようなハイブリッドな構成が可能になります。

- PythonからRustで実装された高速な関数を呼び出す（[PyO3](https://pyo3.rs/)や[maturin](https://www.maturin.rs/)を利用）
- RustからC、C++、Fortranなどで実装された既存のライブラリを呼び出す
- アプリケーション全体はPythonで構築し、計算負荷の高い部分のみをRustで実装する

この特性を活かすことで、既存のPythonスクリプトにおいて性能上のボトルネックとなっている箇所のみをRustで書き換える、といった段階的な導入も可能です。

#### FFIのオーバーヘッドについて

ただし、FFIの利用には以下のようなオーバーヘッドが伴う点に留意が必要です。

- **関数呼び出しコスト**：言語間の境界を越える際に追加的なコストが発生します。
- **データ変換コスト**：言語間でデータ型やメモリレイアウトが異なる場合、その変換コストが発生します。
- **メモリコピー**：データの所有権や安全性を保証するため、言語間でデータを渡す際にメモリコピーが必要になる場合があります。

FFIを効果的に利用するには、以下の点が重要です。

- **適切な粒度の維持**：小さな関数を頻繁に呼び出すのではなく、ある程度まとまった計算を一度の呼び出しで処理する。
- **データ往復の最小化**：可能な限り、データを一度渡して計算を完了させ、結果のみを返すように設計する。
- **ゼロコピーの活用**：メモリレイアウトを共有できる場合は、NumPy配列と`ndarray`間のゼロコピー変換などを利用し、不要なコピーを回避する。

<details>
<summary>メモリレイアウトに関する補足</summary>

Rustのコンパイラは、パフォーマンスを最適化するために、デフォルトで構造体などのデータ型のメモリレイアウト（フィールドの配置順序）を並べ替えることがあります。これはRust内部で完結するコードでは問題になりませんが、C/C++やPythonといった他言語とデータをやり取りする際には問題となります。

他言語との間でデータを正しく解釈するには、両者でメモリレイアウトが一致している必要があります。そのために、Rustでは`#[repr(C)]`というアトリビュートが用意されています。

```rust,noplayground
#[repr(C)]
struct MyData {
    x: f64,
    y: f64,
    z: i32,
}
```

このアトリビュートを構造体に付与することで、フィールドが定義された順序でメモリ上に配置されることが保証され、C言語の構造体と互換性のあるメモリレイアウトになります。

多くの科学技術計算ライブラリ（例えばPythonのNumPy）は、内部的にC言語互換のメモリレイアウトを採用しています。そのため、`#[repr(C)]`を指定したRustのデータ構造とNumPy配列の間では、データの再確保やコピーを伴わない**ゼロコピー**でのデータ共有が可能となり、FFIのオーバーヘッドを最小限に抑えることができます。

</details>

適切に設計することで、FFIのオーバーヘッドは全体の計算時間に対して無視できる程度に抑制することが可能です。実際、NumPy自体もPythonとC/Fortranの間でFFIを利用しており、同様のトレードオフを考慮した上で高いパフォーマンスを実現しています。

## 課題と現実的な考慮事項

ここまでRustの利点を述べてきましたが、採用にあたっては以下の課題も考慮する必要があります。

### 1. 学習コスト

所有権システム、ライフタイム、トレイトといった概念は、他の多くの手続き型言語にはないRust独自のものであり、習得には一定の学習コストを要すると一般的に認識されています。

### 2. 科学計算ライブラリの成熟度

Pythonの科学計算エコシステム（NumPy, SciPy, Matplotlib, pandasなど）は、長年の歴史を通じて非常に成熟しています。一方、Rustのエコシステムはまだ発展途上であり、特定の数値計算アルゴリズムや専門分野に特化したライブラリが存在しない場合もあります。

ただし、基本的な線形代数、高速フーリエ変換（FFT）、常微分方程式ソルバーといった基本的なツールは既に利用可能です。また、前述の通り、必要に応じてC/Fortranなどで書かれた既存のライブラリをFFIで呼び出すことで、機能不足を補うこともできます。

### 3. コンパイル時間とプロトタイピング

Rustは、安全性とパフォーマンスを保証するためにコンパイル時に詳細な静的解析を行います。このため、特に初回ビルドや依存関係が更新された際のコンパイルには時間がかかることがあります。しかし、2回目以降はインクリメンタルコンパイルが働くため、変更があった部分のみが再コンパイルされ、待ち時間は大幅に短縮されます。

また、Rustはコンパイルが必須であるため、PythonのJupyter Notebookのような環境でコードを断片的に実行し、結果を即座に確認するといったインタラクティブな開発は得意ではありません。このため、アイデアを迅速に試すプロトタイピングの場面では、試行錯誤のサイクルが比較的低速になる可能性があります。

## Rustが適するケース

以上の利点と課題を踏まえると、計算物理学においてRustは特に以下のような状況でその真価を発揮します。

- 長時間実行される計算処理で、実行速度がボトルネックとなっている場合
- マルチコアCPUの性能を最大限に引き出したい場合
- 大規模なデータを扱い、メモリ効率が厳しく要求される場合
- コードの安全性や長期的な保守性を高め、リファクタリングや機能追加を安全に行いたい場合
- 既存のPythonコードの一部を高速化したい場合

## 他の言語が適するケース

逆に、以下のような目的や制約がある場合は、他の言語が適している可能性があります。

- 迅速なデータ分析や、使い捨てのスクリプト作成が主目的である場合
- 既存のPythonライブラリに強く依存したエコシステムから離れることが困難な場合
- チーム全体が他の言語に習熟しており、Rustの学習コストを投下することが現実的でない場合

## まとめ

Rustは、**安全性、パフォーマンス、そして並列処理の容易さ**という点において、計算物理学の分野で非常に魅力的な選択肢となります。学習コストやエコシステムの成熟度といった課題は存在するものの、それらを克服することで得られる恩恵は大きく、特にパフォーマンスや信頼性が重視される研究・開発において、Rustは強力なツールとなり得ます。

本書では、Rustのこれらの特性を活かしながら、計算物理学の基本的な手法を実装し、その原理の理解を深めていきます。
