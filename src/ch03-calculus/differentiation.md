# 数値微分

解析的に導関数（微分）を求めることが困難、あるいは不可能な関数に対し、計算機を用いて近似的に微分係数を求める手法を**数値微分 (Numerical Differentiation)** と呼びます。

物理シミュレーションにおいては、物体の運動方程式 $F = m a = m dv(x, t, 2)$ を解く際や、ポテンシャルエネルギー $V(x)$ から力 $F = - dv(V, x)$ を求める際など、至る所で微分計算が必要となります。

本節では、数値微分の最も基本的な手法である**差分法 (Finite Difference Method)** について、その原理とRustによる実装、そして数値計算特有の誤差の振る舞いについて解説します。

## 微分の定義と差分近似

関数 $f(x)$ の $x$ における微分係数 $dv(f, x)$ の数学的な定義は以下の通りです。

$$ dv(f, x) = lim\_(h -> 0) (f(x + h) - f(x)) / h $$

コンピュータでは無限小の極限 $h -> 0$ を直接扱うことはできません。その代わり、十分に小さな有限の値 $h$ （刻み幅、ステップサイズ）を用いて、微分係数を近似します。これを**差分近似**と呼びます。

近似の方法によって、いくつかの種類があります。

### 1. 前進差分 (Forward Difference)

定義式をそのまま用いて、点 $x$ とその少し先の点 $x+h$ の値を使う方法です。

$$ dv(f, x) approx (f(x + h) - f(x)) / h $$

### 2. 後退差分 (Backward Difference)

点 $x$ とその少し手前の点 $x-h$ の値を使う方法です。

$$ dv(f, x) approx (f(x) - f(x - h)) / h $$

### 3. 中心差分 (Central Difference)

点 $x$ を中心とした前後 $x+h$ と $x-h$ の値を使う方法です。

$$ dv(f, x) approx (f(x + h) - f(x - h)) / (2h) $$

幾何学的には、前進差分と後退差分が「2点間の直線の傾き」で接線の傾きを近似するのに対し、中心差分は「前後2点の中点における傾き」を用いていることになります。一般に、**中心差分の方が前進・後退差分よりも高精度**になります（理由は後述します）。

## Rustによる実装

これらの差分法をRustで実装してみましょう。ここでは、関数 $f(x) = sin(x)$ を例にとり、$x = 1.0$ における微分係数を計算します。解析解は $f'(x) = cos(x)$ なので、これと比較して精度を確認します。

```rust
fn main() {
    // 微分対象の関数 f(x) = sin(x)
    let f = |x: f64| x.sin();

    // 微分を計算する点
    let x: f64 = 1.0;

    // 刻み幅 h
    let h: f64 = 0.01;

    // 解析解 (真値): cos(1.0)
    let exact = x.cos();

    // 1. 前進差分
    let diff_forward = (f(x + h) - f(x)) / h;

    // 2. 後退差分
    let diff_backward = (f(x) - f(x - h)) / h;

    // 3. 中心差分
    let diff_central = (f(x + h) - f(x - h)) / (2.0 * h);

    println!("解析解:    {:.10}", exact);
    println!("前進差分:  {:.10} (誤差: {:.2e})", diff_forward, (diff_forward - exact).abs());
    println!("後退差分:  {:.10} (誤差: {:.2e})", diff_backward, (diff_backward - exact).abs());
    println!("中心差分:  {:.10} (誤差: {:.2e})", diff_central, (diff_central - exact).abs());
}
```

実行結果の例：

```text
解析解:    0.5403023059
前進差分:  0.5360859810 (誤差: 4.22e-3)
後退差分:  0.5445006207 (誤差: 4.20e-3)
中心差分:  0.5402933009 (誤差: 9.00e-6)
```

この結果から、同じ刻み幅 $h=0.01$ でも、中心差分の方が圧倒的に誤差が小さいことがわかります。

## 誤差の解析：なぜ中心差分が良いのか？

テイラー展開を用いて誤差（打ち切り誤差）を評価することで、この理由を数学的に説明できます。

関数 $f(x)$ を $x$ の周りでテイラー展開すると以下のようになります。

$$ f(x + h) = f(x) + h f'(x) + h^2/2 f''(x) + h^3/6 f'''(x) + ... $$

$$ f(x - h) = f(x) - h f'(x) + h^2/2 f''(x) - h^3/6 f'''(x) + ... $$

### 前進差分の誤差

前進差分の式にテイラー展開を代入して整理すると：

$$ (f(x+h) - f(x)) / h = f'(x) + h/2 f''(x) + ... $$

つまり、近似値と真値 $f'(x)$ との差（誤差）は、**$h$ の1乗に比例**します（オーダー $O(h)$）。

### 中心差分の誤差

一方、中心差分の式 $(f(x+h) - f(x-h)) / (2h)$ に代入すると、偶数次の項が相殺されます。

$$ (f(x+h) - f(x-h)) / (2h) = f'(x) + h^2/6 f'''(x) + ... $$

こちらの誤差は、**$h$ の2乗に比例**します（オーダー $O(h^2)$）。

$h$ が小さい場合（例：$h = 0.01 = 10^(-2)$）、$h^2 = 10^(-4)$ となり、$h$ に比べてはるかに小さくなります。これが、中心差分が高精度である理由です。

## 最適なステップサイズと丸め誤差

「$h$ を小さくすればするほど精度が良くなる」と考えがちですが、数値計算ではそう単純ではありません。コンピュータの浮動小数点数には**丸め誤差**が存在するためです。

$h$ を極端に小さくすると、分子の $f(x+h) - f(x)$ において、非常に近い値同士の引き算（**桁落ち**）が発生し、有効桁数が失われてしまいます。

実際に $h$ を変化させながら誤差をプロットしてみると、以下のようになります。

1. **打ち切り誤差支配領域**: $h$ が大きい領域。テイラー展開の近似誤差が支配的で、$h$ を小さくすると精度が向上する。
2. **丸め誤差支配領域**: $h$ が小さすぎる領域。桁落ちによる丸め誤差が支配的で、$h$ を小さくすると逆に精度が悪化する。

最適な $h$ は、これら2つの誤差のバランスが取れる点に存在します。

### 実験：最適な`h`を探る

以下のコードで、$h$ を $10^(-1)$ から $10^(-16)$ まで変化させたときの誤差を確認してみましょう。

```rust
fn main() {
    let f = |x: f64| x.sin();
    let x: f64 = 1.0;
    let exact = x.cos();

    println!("h,      Error (Central)");

    let mut h = 1.0;
    for _ in 0..16 {
        h /= 10.0;
        let approx = (f(x + h) - f(x - h)) / (2.0 * h);
        let error = (approx - exact).abs();
        println!("{:.1e}, {:.2e}", h, error);
    }
}
```

実行結果：

```text
h,      Error (Central)
1.0e-1, 9.00e-4
1.0e-2, 9.00e-6
1.0e-3, 9.01e-8
1.0e-4, 9.00e-10
1.0e-5, 1.11e-11
1.0e-6, 2.77e-11
1.0e-7, 1.94e-10
1.0e-8, 2.97e-9
...
1.0e-16, 1.48e-2
```

倍精度浮動小数点数（`f64`）を用いる場合、中心差分における最適な $h$ はおおよそ $10^(-5)$ 〜 $10^(-6)$ 程度になります（関数のスケールにもよりますが、マシンイプシロン $epsilon approx 10^(-16)$ に対して $h approx root(3, epsilon)$ 程度が目安と言われます）。

> [!NOTE]
> 実用的な数値計算ライブラリでは、このような最適な $h$ を自動的に推定するアルゴリズムが組み込まれている場合もあります。

## 2階微分の数値計算

運動方程式 $F = m dv(x, t, 2)$ などで登場する2階微分 $dv(f, x, 2)$ も、中心差分法を応用して求めることができます。

$$ dv(f, x, 2) approx (f(x + h) - 2f(x) + f(x - h)) / h^2 $$

この近似式の誤差も $O(h^2)$ です。

```rust,noplayground
fn second_derivative_central<F>(f: F, x: f64, h: f64) -> f64
where
    F: Fn(f64) -> f64,
{
    (f(x + h) - 2.0 * f(x) + f(x - h)) / (h * h)
}
```

## まとめ

- 数値微分には**前進差分**、**後退差分**、**中心差分**などの手法がある。
- **中心差分**は $O(h^2)$ の精度を持ち、他の2つ（$O(h)$）より高精度であるため、通常はこれが推奨される。
- ステップサイズ $h$ は小さければ良いわけではなく、**丸め誤差（桁落ち）**に注意する必要がある。
- `f64` を用いる場合、中心差分での最適な $h$ は $10^(-5)$ 程度が目安となる。

[次節](./integration.md)では、数値積分について学びます。

<details>
<summary>コラム: 自動微分 (Automatic Differentiation) について</summary>

本節では「差分法」による数値微分を学びましたが、コンピュータで微分を行う手法は他にもあります。特に近年注目されているのが**自動微分 (Automatic Differentiation, AD)** です。

**差分法 vs 自動微分**

- **差分法 (Finite Difference)**:
  - 定義通りに微小な幅 $h$ での傾きを計算する。
  - **長所**: 実装が簡単。関数の中身を知らなくても（ブラックボックスでも）計算可能。
  - **短所**: 打ち切り誤差と丸め誤差のジレンマがある（完全な精度は出ない）。
  - **用途**: 偏微分方程式を格子状に離散化して解く手法（差分法）など、場のシミュレーションで主役となる。

- **自動微分 (AD)**:
  - プログラムの構成要素（足し算、掛け算、sinなど）に対して「連鎖律 (Chain Rule)」を適用し、機械的に導関数を計算する。
  - **長所**: **解析解と同じ精度**が得られる（誤差は浮動小数点数の丸め誤差のみ）。$h$ の調整が不要。
  - **短所**: コンパイラやライブラリの特別なサポートが必要。
  - **用途**: 機械学習（バックプロパゲーション）や物理シミュレーションのパラメータ最適化（逆解析）。

**Rustと `std::autodiff`**

Rustコミュニティでは、コンパイラレベルで自動微分をサポートする取り組み（[`std::autodiff`](https://doc.rust-lang.org/std/autodiff/index.html)の提案や Enzyme プロジェクトとの統合など）が進められています。これが実現すれば、物理シミュレーションのコードを書くだけで、そのパラメータに対する感度解析や最適化が簡単に分かるようになるかも知れません。

本書では、物理シミュレーションの基礎原理（運動方程式をどう離散化するか）を理解するために「差分法」を中心に扱いますが、最適化問題を扱う第5章などでは、ADの考え方が重要になります。

</details>
