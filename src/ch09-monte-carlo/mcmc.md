# マルコフ連鎖モンテカルロ法 (MCMC)

複雑な関数や、高次元で規格化定数が未知の確率密度関数 $P(x)$ に従ってサンプリングを行いたい場合、単純な重点サンプリングは困難になります。これを解決するのが**マルコフ連鎖モンテカルロ法 (Markov Chain Monte Carlo, MCMC)** です。

## メトロポリス法 (Metropolis Algorithm)

MCMCの最も基本的かつ強力なアルゴリズムが**メトロポリス法**です。
「現在の状態 $x$ から、次の状態 $x'$ を提案し、特定の確率でそれを受け入れるか決める」という手順を繰り返します。

### アルゴリズムの手順

1. 初期状態 $x$ を決める。
2. 以下の手順を何度も繰り返す：
   a. 現在の状態 $x$ の近くにある候補状態 $x'$ をランダムに選ぶ（提案分布）。
   b. 受理確率 $w$ を計算する：
   $$ w = min(1, P(x') / P(x)) $$
   c. $[0, 1]$ の一様乱数 $r$ を生成し、$r < w$ なら新しい状態を採用し $x leftarrow x'$ とする。そうでなければ現在の状態 $x$ を維持する。
   d. 現在の状態 $x$ を記録する。

### なぜこれでうまくいくのか

この手順（マルコフ連鎖）を十分長く繰り返すと、状態 $x$ が出現する頻度が目的の分布 $P(x)$ に収束します（詳細釣合い条件）。

最大の特徴は、**$P(x)$ の絶対値ではなく比 $P(x') / P(x)$ さえ分かればよい**点です。物理学において、規格化定数（分配関数）を計算せずにサンプリングができるこの性質は極めて重要です。

## Rustによる実装例

1次元の正規分布 $P(x) propto exp(-x^2 / 2)$ からのサンプリングをメトロポリス法で行います。

```rust
use rand::prelude::*;

fn main() {
    let mut rng = thread_rng();
    let mut x = 0.0; // 初期値
    let delta = 0.5; // 提案の幅
    
    let p = |x: f64| (-x * x / 2.0).exp(); // 目的の分布（規格化不要）

    let n_steps = 100_000;
    let mut samples = Vec::with_capacity(n_steps);

    for _ in 0..n_steps {
        // 1. 候補 x' を提案
        let x_next = x + rng.gen_range(-delta..delta);
        
        // 2. 受理確率の計算
        let acceptance_prob = (p(x_next) / p(x)).min(1.0);
        
        // 3. 受理判定
        if rng.gen::<f64>() < acceptance_prob {
            x = x_next;
        }
        
        samples.push(x);
    }
    
    // 最初の数千ステップ（バーンイン期間）を除いた平均
    let mean: f64 = samples.iter().skip(1000).sum::<f64>() / (n_steps - 1000) as f64;
    println!("Estimated mean = {:.6}", mean);
}
```

## 注意点

1. **バーンイン (Burn-in)**: 初期値の影響が残っている最初の数ステップは捨てる必要があります。
2. **相関**: MCMCで得られるサンプルは独立ではなく、直前の状態と強い相関（自己相関）を持っています。

---

第9章はこれで終わりです。次は、これまで学んだ手法を具体的な物理系に適用する、**第10章: 古典力学シミュレーション**に進みましょう。
