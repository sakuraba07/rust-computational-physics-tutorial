# ルンゲ＝クッタ法

**ルンゲ＝クッタ法 (Runge-Kutta Methods)** は、オイラー法よりも高精度に微分方程式を解くための一連の手法です。その中でも特に、**4次のルンゲ＝クッタ法 (RK4)** が実用上の標準として広く使われています。

## 4次のルンゲ＝クッタ法 (RK4)

オイラー法が区間の始点での傾きだけを使ったのに対し、RK4では区間内の4点の傾きを計算し、それらを加重平均して次の値を決定します。

微分方程式 $dv(x, t) = f(t, x)$ に対して、時間刻み $h$ での更新式は以下の通りです。

$$ k_1 = f(t_n, x_n) $$

$$ k_2 = f(t_n + h/2, x_n + h/2 k_1) $$

$$ k_3 = f(t_n + h/2, x_n + h/2 k_2) $$

$$ k_4 = f(t_n + h, x_n + h k_3) $$

$$ x_(n+1) = x_n + h/6 (k_1 + 2k_2 + 2k_3 + k_4) $$

幾何学的意味：

1. $k_1$: 始点での傾き（オイラー法と同じ）。
2. $k_2$: $k_1$ を使って中点へ進み、そこでの傾き。
3. $k_3$: $k_2$ を使って中点へ進み（修正）、そこでの傾き。
4. $k_4$: $k_3$ を使って終点へ進み、そこでの傾き。
5. 最後にこれらを $1:2:2:1$ の重みで平均します。

この手法の大域誤差は **$O(h^4)$（4次精度）** です。$h$ を半分にすると、誤差は約 $1/16$ に激減します。

## Rustによる実装（ジェネリック）

スカラ（1変数）だけでなく、ベクトル（連立方程式）も扱えるようにジェネリクスを使って実装してみましょう。

```rust
use std::ops::{Add, Mul};

// ベクトル演算に必要なトレイト境界
// (実際には `num-traits` や `ndarray` を使うとよりスムーズですが、ここでは標準ライブラリ風に記述します)
// 簡易化のため、f64のベクトル `Vec<f64>` を状態として扱う例を示します。

// 状態ベクトルに対する演算を定義
fn add(a: &[f64], b: &[f64]) -> Vec<f64> {
    a.iter().zip(b).map(|(x, y)| x + y).collect()
}

fn scale(a: &[f64], s: f64) -> Vec<f64> {
    a.iter().map(|x| x * s).collect()
}

/// 4次のルンゲ＝クッタ法
/// state: 現在の状態ベクトル x
/// f: 微分方程式の右辺 dx/dt = f(t, x)
/// t: 現在の時刻
/// h: 時間刻み
fn rk4<F>(state: &[f64], f: &F, t: f64, h: f64) -> Vec<f64>
where
    F: Fn(f64, &[f64]) -> Vec<f64>,
{
    let k1 = f(t, state);
    let k2 = f(t + h * 0.5, &add(state, &scale(&k1, h * 0.5)));
    let k3 = f(t + h * 0.5, &add(state, &scale(&k2, h * 0.5)));
    let k4 = f(t + h, &add(state, &scale(&k3, h)));

    // result = state + (h/6) * (k1 + 2k2 + 2k3 + k4)
    let slope = add(
        &add(&k1, &k4),
        &scale(&add(&k2, &k3), 2.0)
    );
    
    add(state, &scale(&slope, h / 6.0))
}

fn main() {
    // 例：単振動 (調和振動子) dv(x, t) = v, dv(v, t) = -x
    // 状態ベクトル x = [position, velocity]
    let system = |_t: f64, state: &[f64]| -> Vec<f64> {
        let x = state[0];
        let v = state[1];
        vec![v, -x]
    };

    let mut state = vec![1.0, 0.0]; // 初期位置 1.0, 初期速度 0.0
    let mut t = 0.0;
    let h = 0.1;

    for _ in 0..100 {
        state = rk4(&state, &system, t, h);
        t += h;
        println!("t={:.2}, x={:.6}, v={:.6}", t, state[0], state[1]);
    }
}
```

## 注意点

RK4は非常に優秀ですが、**万能ではありません**。
「硬い方程式 (Stiff Equation)」と呼ばれる、時間スケールが大きく異なる現象が混在する系（例：非常に速い化学反応と遅い拡散が混ざる場合など）に対しては、RK4は不安定になりやすく、ステップ幅 $h$ を極端に小さくする必要があります。
そのような場合は、陰的解法（Implicit Method）などが用いられます。

<details>
<summary>コラム: エネルギー保存とシンプレクティック積分</summary>

ルンゲ＝クッタ法（RK4）は非常に高精度ですが、長時間にわたってハミルトン系（エネルギー保存系）を計算する場合、**エネルギーが保存せず、徐々にズレていく**という欠点があります。

例えば、惑星の軌道をRK4で何周も計算すると、軌道が徐々に内側に落ち込んでいったり、外側に発散していったりします（減衰項がないにもかかわらず！）。これは数値計算法自体が持つ微小なエネルギー散逸（または生成）によるものです。

これに対し、**シンプレクティック積分法 (Symplectic Integrator)** と呼ばれる一群の手法（リープフロッグ法やベレ法など）は、厳密なハミルトニアンそのものではありませんが、元のハミルトニアンに近い「影のハミルトニアン」を厳密に保存する性質を持っています。そのため、長時間計算してもエネルギーが振動するだけで発散せず、軌道の形状が安定して保たれます。

天体力学や分子動力学など、長時間の安定性が求められるシミュレーションでは、精度の高いRK4よりも、安定性の高いシンプレクティック積分法が好まれることが多いです。[第10章](../ch10-classical-mechanics/README.md)では、このシンプレクティック積分について詳しく扱います。

</details>

---

[次節](./adaptive-step.md)では、計算精度を保ちながら効率よく計算するために、ステップ幅 $h$ を自動調整する方法を学びます。
