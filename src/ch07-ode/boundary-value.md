# 境界値問題

これまで扱ってきたのは、$t=0$ での $x$ と $v$ が分かっていて、そこから未来を予測する**初期値問題 (Initial Value Problem, IVP)** でした。

しかし、物理学では「始点と終点の状態が決まっている」問題も頻繁に現れます。これを**境界値問題 (Boundary Value Problem, BVP)** と呼びます。

例：

- **固定された弦**: 両端 $x(0) = 0, x(L) = 0$ が固定されている。
- **ポアソン方程式**: 電位分布を求める際、領域の境界での電位が決まっている。
- **量子力学の固有値問題**: 波動関数が無限遠でゼロになる $psi(infinity) -> 0$。

## シューティング法 (Shooting Method)

境界値問題を解くための直感的な手法が**シューティング法（射撃法）**です。これは境界値問題を「パラメータ探索付きの初期値問題」に変換する手法です。

### アルゴリズム

2階微分方程式 $dv(x, t, 2) = f(t, x, dv(x, t))$ を考えます。
境界条件が $x(t_0) = A, quad x(t_1) = B$ で与えられているとします。

通常の初期値問題として解くには、初期速度 $v(t_0) = dv(x, t)(t_0)$ が必要ですが、これは未知数です。

1. 初期速度に適当な推測値 $alpha$ を仮定します。 $v(t_0) = alpha$
2. この初期条件 $x(t_0) = A, v(t_0) = alpha$ を使って、オイラー法やルンゲ＝クッタ法で $t_1$ まで計算します。
3. 計算結果の終端位置 $x(t_1)$ が、目的の境界条件 $B$ と一致するか確認します。
4. 一致しない場合、誤差 $E(alpha) = x(t_1; alpha) - B$ を計算します。
5. $E(alpha) = 0$ となるような $alpha$ を、求根アルゴリズム（二分法やニュートン法）を使って探します。

まさに「的に向かって大砲の角度（初期速度）を調整しながら撃つ」イメージです。

### Rustによる実装イメージ

```rust
// 仮想的なコード（疑似コードに近い）
fn main() {
    let target_b = 0.0; // x(t_1) = 0
    
    // 目的関数: 初期速度 v0 を与えると、終端での誤差を返す
    let error_func = |v0: f64| -> f64 {
        let state = solve_ode_ivp(v0); // RK4などで t_0 -> t_1 まで計算
        let x_final = state.x;
        x_final - target_b
    };
    
    // 二分法などで error_func(v0) = 0 となる v0 を探す
    let v0_solution = bisection_method(error_func, -10.0, 10.0);
    
    println!("求める初期速度: {}", v0_solution);
}
```

## その他の手法

シューティング法は直感的ですが、方程式が不安定な場合（初期値のわずかなズレが終端で増幅される場合）にはうまくいきません。その場合は、以下のような手法が使われます。

- **有限差分法 (Finite Difference Method)**:
  時間（または空間）領域を格子状に分割し、微分方程式を連立方程式 $A vb(x) = vb(b)$ に近似して一気に解きます。第8章の偏微分方程式で詳しく扱います。

---

第7章はこれで終わりです。次は[第8章: 偏微分方程式](../ch08-pde/README.md)に進みましょう。
